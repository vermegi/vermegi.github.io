---
title: "Building a cross platform solution for Windows Phone and Windows 8."
subtitle: "Part IV: Mocking out the differences"
layout: "post"
permalink: "/2013/12/building-cross-platform-solution-for_15.html"
uuid: "1729212943909325403"
guid: "tag:blogger.com,1999:blog-4315928131887373364.post-1729212943909325403"
date: "2013-12-15 16:39:00"
updated: "2013-12-17 14:16:07"
description: 
blogger:
    siteid: "4315928131887373364"
    postid: "1729212943909325403"
    comments: "1"
categories: [MVVM, Windows Phone, Windows 8, cross platform]
author: "Gitte Vermeiren"
header-img: "img/mobile.jpg"
---

<div class="css-full-post-content js-full-post-content">
Other parts in this series:<br /><br /><a href="http://proq.blogspot.be/2013/12/building-cross-platform-solution-for.html">Part 0: Intro</a><br /><a href="http://proq.blogspot.be/2013/12/building-cross-platform-solution-for_2.html">Part I: Quick sharing of code</a><br /><a href="http://proq.blogspot.be/2013/12/building-cross-platform-solution-for_3.html">Part II: The class library approach</a><br /><a href="http://proq.blogspot.be/2013/12/building-cross-platform-solution-for_8.html">Part III: We need a pattern</a><br /><a href="http://proq.blogspot.be/2013/12/building-cross-platform-solution-for_15.html">Part IV: Mocking out the differences</a><br />Part V: Event to command<br />Part VI: Behaviors for coping with orientation changes<br />Part VII: Tombstoning<br /><br />In the previous part I talked about the MVVM pattern as a great way to share logic in your application. Your ViewModel (and Model) code can be placed in a portable class library, thus making it reusable. But, since it is not possible to put any platform specific code in your PCL, you cannot directly use platform specific services from within a ViewModel (this would make your PCL unsharable between platforms). This poses some challenges, but these can quite easily be overcome. This part in our series will be the most extensive thus far, and will contain the most advanced concepts, like inversion of control, dependency injection, and reflection. But bear with me, it will all be worth it in the end!<br /><br />Let's first look at one of these platform specific behaviors: Windows Phone and Windows 8 both allow you to navigate from one page to another. The way they do this, however, is different between the two platforms. They both have a Navigate method for this, but the method exists on two different types, and also, the actual parameterlist of this method is different on each platform. You will need to find a solution to get a comparable way of navigating between pages on both platforms. You can do this by wrapping the platform specific functionality with an interface. Your ViewModels can then talk to this interface instead of talking directly to the actual navigation service of each platform.<br /><br />I have for instance a MainViewModel which acts as start page for my application. From this MainViewModel you can navigate to other pages in the application. For this, the MainViewModel gets a reference to a INavigate interface through its constructor (this is my own INavigate interface, and not the one you can find in the Windows Store or Windows Phone API). Since I will be navigating in my ViewModels and not in my Views, I decided that when I navigate to another page, this is actually the same as navigating to another ViewModel. Also, I want to be able, when I navigate, to send along an additional parameter, which contains extra data for the ViewModel I navigate to.<br /><br /><script src="https://gist.github.com/vermegi/7974904.js"></script><br /><br />In the above code you can see it is quite easy to navigate to another ViewModel, and send along extra data (navigate to the SudokuBoardViewModel with a specific game level). But you can also choose not to use this extra data (navigate to the SudokuRulesViewModel).<br /><br />The interface itself has one extra method for navigating back.<br /><br /><script src="https://gist.github.com/vermegi/7974916.js"></script><br /><br />What you will still have to do now is write platform specific implementations of the INavigate service for each platform you want to support. The good thing is, you will need to write this kind of implementations only once. After your first app, you can reuse this effort to a next application (and I will also make sure my own little API will become available on github in the next couple of weeks).<br /><br /><br /><h3>1. Navigating in a Windows Store application</h3><br />Let's first look at the WindowsStoreNavigator, since this is the easiest to understand. To navigate from one page to the next, you need to make use of your Window.Current.Content property (or rootframe). In a clean Windows Store project you get a reference to this in your OnLaunched event (I set up the entire framework from the OnLaunched handler in the app.xaml.cs file). Next, we will also need some means of associating the ViewModel we wish to navigate to, with a certain View, since navigating in Windows Store applications is done to views and not to viewmodels. For this I will utilize a viewlocator (IKnowWhereYourViewIs). This viewlocator is nothing more than a dictionary that associates views to viewmodels. This way I don't need to code the binding between view and viewmodel directly in the view or in the viewmodel.<br /><br /><script src="https://gist.github.com/vermegi/7974933.js"></script><br /><br />As you can see, I ask the viewlocator for the view that is associated with the viewmodel I wish to navigate to. Next I tell the rootframe to actually navigate to this view. The second parameter in the second line of the NavigateTo method instantiates my viewmodel. The inversion of control container has been set up with a list of all my viewmodels. For this I utilized TinyIoc, but you can use any wich IoC you like. The main advantage using and IoC container will be that any dependencies your viewmodel uses, will get injected by the IoC, as long as you registered them at startup.<br /><br />Navigating with the extra data is a bit more complex. I created a IHandle interface which indicates wether a ViewModel can handle a certain message. If it does, it implements the IHandle<requesttype> interface. Before navigating to the view, I first let the ViewModel handle the actual request.</requesttype><br /><br /><script src="https://gist.github.com/vermegi/7974957.js"></script><br /><br />One more thing missing after navigating to a certain view, is the actual databinding between View and ViewModel. For this I created an extra base class for each View. In the OnNavigatedTo handler, we will bind the NavigationEventArgs, which in our case is our ViewModel, to the Views' DataContext.<br /><br /><script src="https://gist.github.com/vermegi/7974966.js"></script><br /><br />And that's it. This allows us to navigate from one ViewModel to another, while sending along data. Also aer we now able to actually databind our ViewModel to the actual View.<br /><br /><br /><h3>2. Navigating in a Windows Phone application</h3><br />Now that we can navigate in a Windows Store application, let's do the same thing for Windows Phone. As you will see, the API for navigating in Windows Phone is different from the one Windows Store applications use. In Windows Phone you navigate based on a Uri. Also, we will not be able to send along our ViewModel and request as easily. In this case, we will serialize everything before we navigate. Ie. we will serialize our ViewModel type, the actual request and the request type.<br /><br /><script src="https://gist.github.com/vermegi/7974981.js"></script><br /><br />Again, we will use a MvvmPage base class, which all our views can inherit from. In its NavigatedTo event handler we will now have to (re)create our ViewModel and request. I pulled out this code to another class which implements ICreateViewModels. Since views cannot use dependency injection, I wrapped the IoC in a singleton, which can give me my viewmodelcreator.<br /><br /><script src="https://gist.github.com/vermegi/7975006.js"></script><br /><br />The ViewModelCreator then uses a deserializer and some reflection to recreate the viewmodel and to make it handle the actual request.<br /><br /><script src="https://gist.github.com/vermegi/7975020.js"></script><br /><br />The above code is actually the most complex part of the entire framework. An, as said, code like this, you will only have to provide once, after that your can reuse it for your next applications.<br /><br />Once you got thi plumbing in place, you can navigate between ViewModels in a way that is reusable on Windows Store and Windows Phone applications. It wil make it easier to put your logic code in a shared library and to easily make changes to it that will get reflected on each platform.<br /><br />Hang on for the next part, where I will talk about some extra helper classes to make MVVM work better for you.<br /><br /><br />Other parts in this series:<br /><br /><a href="http://proq.blogspot.be/2013/12/building-cross-platform-solution-for.html">Part 0: Intro</a><br /><a href="http://proq.blogspot.be/2013/12/building-cross-platform-solution-for_2.html">Part I: Quick sharing of code</a><br /><a href="http://proq.blogspot.be/2013/12/building-cross-platform-solution-for_3.html">Part II: The class library approach</a><br /><a href="http://proq.blogspot.be/2013/12/building-cross-platform-solution-for_8.html">Part III: We need a pattern</a><br /><a href="http://proq.blogspot.be/2013/12/building-cross-platform-solution-for_15.html">Part IV: Mocking out the differences</a><br />Part V: Event to command<br />Part VI: Behaviors for coping with orientation changes<br />Part VII: Tombstoning<br /><div><br /></div>
</div>
<div class="css-full-comments-content js-full-comments-content">
<div class="css-full-comment js-full-comment">
  <div class="css-comment-user-link js-comment-user-link">
  <a href="http://www.blogger.com/profile/01328753280859635286">
  <div class="css-comment-name js-comment-name">
    Buddy James
  </div>
  </a>
  <div class="css-comment-date js-comment-date">
    2014-04-15T17:42:09.056Z
  </div>
  </div>
  <div class="css-comment-content js-comment-content">
    Great series of articles!<br /><br />A little constructive criticism though..<br /><br />The way that you are using your Ioc container looks an awful lot like the Service Locator pattern which is an Anti-Pattern.  You use dependency injection correctly when your interfaces are injected into your constructors, however, your command properties use the IoC container to blindly instantiate new instances of each command if the command&#39;s private field is null.  Generally, you should only use an IoC container to resolve an object graph in your App&#39;s code behind.  This is known as the &quot;Composition root&quot;.  The way that you use the IoC container in the property getter to instantiate the commands that don&#39;t exist is basically identical to using the new keyword, however, since you are using your container, you are actually adding dependencies on your container rather than removing dependencies.  In a multi-team environment, you can&#39;t be sure if all of the command types are registered in your IoC container.  If you register all dependencies in your composition root, and then &quot;resolve&quot; (I use Unity, hence the terminology) the current page to be accessed, then all of the pages dependencies will be created by the container, and all of the dependencies dependencies will be created, all the way down the object graph.  This is the purpose of Inversion of control.  It inverts the responsibility of creating instances of your dependencies inward so that it&#39;s all handled at once in the composition root of your application.  You also use the Singleton pattern which is another Anti-Pattern.  I hope this helps.  Otherwise, great articles!  You can visit my blog where I have a few examples of Dependency injection with the Unity IoC container: http://www.refactorthis.net .  Keep up the good work.  Buddy James <br /><br />
  </div>
  <br/>
</div>
</div>